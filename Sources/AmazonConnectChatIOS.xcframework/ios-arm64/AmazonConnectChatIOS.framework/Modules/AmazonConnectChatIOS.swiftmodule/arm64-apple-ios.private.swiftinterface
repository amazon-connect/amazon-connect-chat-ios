// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.8 clang-1700.4.4.1)
// swift-module-flags: -target arm64-apple-ios15.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name AmazonConnectChatIOS
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import AWSConnectParticipant
import AWSCore
@_exported import AmazonConnectChatIOS
import Combine
import Foundation
import Network
import OSLog
import Swift
import UIKit
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
public enum WebSocketErrorCodes : Swift.Int {
  case NETWORK_DISCONNECTED
  case BAD_SERVER_RESPONSE
  case SOFTWARE_ABORT
  case OPERATION_TIMED_OUT
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.Int)
  #endif
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct ConnectionDetails {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(websocketUrl: Swift.String?, connectionToken: Swift.String?, expiry: Foundation.Date?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getWebsocketUrl() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getConnectionToken() -> Swift.String?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getExpiry() -> Foundation.Date?
  #endif
}
public struct Constants {
  public static let QUICK_REPLY: Swift.String
  public static let LIST_PICKER: Swift.String
  public static let PANEL: Swift.String
  public static let TIME_PICKER: Swift.String
  public static let CAROUSEL: Swift.String
  public static let VIEW_RESOURCE: Swift.String
}
public class TranscriptResponse : Swift.Equatable {
  public static func == (lhs: AmazonConnectChatIOS.TranscriptResponse, rhs: AmazonConnectChatIOS.TranscriptResponse) -> Swift.Bool
  final public let initialContactId: Swift.String
  final public let nextToken: Swift.String
  public var transcript: [AmazonConnectChatIOS.TranscriptItem]
  public init(initialContactId: Swift.String, nextToken: Swift.String, transcript: [AmazonConnectChatIOS.TranscriptItem])
  @objc deinit
}
public struct ViewResource {
  public let id: Swift.String?
  public let name: Swift.String?
  public let arn: Swift.String?
  public let version: Swift.Int?
  public let content: [Swift.String : Any]?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(id: Swift.String?, name: Swift.String?, arn: Swift.String?, version: Swift.Int?, content: [Swift.String : Any]?)
  #endif
}
public protocol ChatSessionProtocol {
  func configure(config: AmazonConnectChatIOS.GlobalConfig)
  func getConnectionDetailsProvider() -> any AmazonConnectChatIOS.ConnectionDetailsProviderProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  func connect(chatDetails: AmazonConnectChatIOS.ChatDetails, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func disconnect(completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  func suspendWebSocketConnection()
  func resumeWebSocketConnection()
  func reset()
  #if compiler(>=5.3) && $NonescapableTypes
  func sendMessage(contentType: AmazonConnectChatIOS.ContentType, message: Swift.String, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func resendFailedMessage(messageId: Swift.String, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func sendEvent(event: AmazonConnectChatIOS.ContentType, content: Swift.String, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  func sendMessageReceipt(for transcriptItem: AmazonConnectChatIOS.TranscriptItem, eventType: AmazonConnectChatIOS.MessageReceiptType)
  #if compiler(>=5.3) && $NonescapableTypes
  func getTranscript(scanDirection: AWSConnectParticipantScanDirection?, sortOrder: AWSConnectParticipantSortKey?, maxResults: Foundation.NSNumber?, nextToken: Swift.String?, startPosition: Swift.String?, completion: @escaping (Swift.Result<AmazonConnectChatIOS.TranscriptResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func sendAttachment(file: Foundation.URL, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func downloadAttachment(attachmentId: Swift.String, filename: Swift.String, completion: @escaping (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func getAttachmentDownloadUrl(attachmentId: Swift.String, completion: @escaping (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void)
  #endif
  func isChatSessionActive() -> Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  var onConnectionEstablished: (() -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onConnectionReEstablished: (() -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onConnectionBroken: (() -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onMessageReceived: ((AmazonConnectChatIOS.TranscriptItem) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onTranscriptUpdated: ((AmazonConnectChatIOS.TranscriptData) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onChatEnded: (() -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onDeepHeartbeatFailure: (() -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onParticipantIdle: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onParticipantReturned: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onAutoDisconnection: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onTyping: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onReadReceipt: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onDeliveredReceipt: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onParticipantInvited: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onChatRehydrated: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onTransferSucceeded: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var onTransferFailed: ((AmazonConnectChatIOS.Event?) -> Swift.Void)? { get set }
  #endif
}
@_hasMissingDesignatedInitializers public class ChatSession : AmazonConnectChatIOS.ChatSessionProtocol {
  public static let shared: any AmazonConnectChatIOS.ChatSessionProtocol
  public var globalConfig: AmazonConnectChatIOS.GlobalConfig?
  public var onConnectionEstablished: (() -> Swift.Void)?
  public var onConnectionReEstablished: (() -> Swift.Void)?
  public var onConnectionBroken: (() -> Swift.Void)?
  public var onMessageReceived: ((AmazonConnectChatIOS.TranscriptItem) -> Swift.Void)?
  public var onTranscriptUpdated: ((AmazonConnectChatIOS.TranscriptData) -> Swift.Void)?
  public var onChatEnded: (() -> Swift.Void)?
  public var onDeepHeartbeatFailure: (() -> Swift.Void)?
  public var onParticipantIdle: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onParticipantReturned: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onAutoDisconnection: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onTyping: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onReadReceipt: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onDeliveredReceipt: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onParticipantInvited: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onChatRehydrated: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onTransferSucceeded: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public var onTransferFailed: ((AmazonConnectChatIOS.Event?) -> Swift.Void)?
  public func isChatSessionActive() -> Swift.Bool
  public func configure(config: AmazonConnectChatIOS.GlobalConfig)
  public func getConnectionDetailsProvider() -> any AmazonConnectChatIOS.ConnectionDetailsProviderProtocol
  #if compiler(>=5.3) && $NonescapableTypes
  public func connect(chatDetails: AmazonConnectChatIOS.ChatDetails, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getTranscript(scanDirection: AWSConnectParticipantScanDirection? = .backward, sortOrder: AWSConnectParticipantSortKey? = .ascending, maxResults: Foundation.NSNumber? = 30, nextToken: Swift.String? = nil, startPosition: Swift.String? = nil, completion: @escaping (Swift.Result<AmazonConnectChatIOS.TranscriptResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func describeView(viewToken: Swift.String, completion: @escaping (Swift.Result<AmazonConnectChatIOS.ViewResource, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func disconnect(completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  public func suspendWebSocketConnection()
  public func resumeWebSocketConnection()
  #if compiler(>=5.3) && $NonescapableTypes
  public func sendMessage(contentType: AmazonConnectChatIOS.ContentType, message: Swift.String, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func resendFailedMessage(messageId: Swift.String, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func sendEvent(event: AmazonConnectChatIOS.ContentType, content: Swift.String, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  public func sendMessageReceipt(for transcriptItem: AmazonConnectChatIOS.TranscriptItem, eventType: AmazonConnectChatIOS.MessageReceiptType)
  #if compiler(>=5.3) && $NonescapableTypes
  public func sendAttachment(file: Foundation.URL, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func downloadAttachment(attachmentId: Swift.String, filename: Swift.String, completion: @escaping (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func getAttachmentDownloadUrl(attachmentId: Swift.String, completion: @escaping (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void)
  #endif
  public func reset()
  @objc deinit
}
open class AWSClient {
  public static let shared: AmazonConnectChatIOS.AWSClient
  public init()
  public func configure(with config: AmazonConnectChatIOS.GlobalConfig)
  #if compiler(>=5.3) && $NonescapableTypes
  open func createParticipantConnection(participantToken: Swift.String, completion: @escaping (Swift.Result<AmazonConnectChatIOS.ConnectionDetails, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func disconnectParticipantConnection(connectionToken: Swift.String, completion: @escaping (Swift.Result<AWSConnectParticipant.AWSConnectParticipantDisconnectParticipantResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func sendMessage(connectionToken: Swift.String, contentType: AmazonConnectChatIOS.ContentType, message: Swift.String, completion: @escaping (Swift.Result<AWSConnectParticipant.AWSConnectParticipantSendMessageResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func sendEvent(connectionToken: Swift.String, contentType: AmazonConnectChatIOS.ContentType, content: Swift.String = "", completion: @escaping (Swift.Result<AWSConnectParticipant.AWSConnectParticipantSendEventResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func startAttachmentUpload(connectionToken: Swift.String, contentType: Swift.String, attachmentName: Swift.String, attachmentSizeInBytes: Swift.Int, completion: @escaping (Swift.Result<AWSConnectParticipant.AWSConnectParticipantStartAttachmentUploadResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func completeAttachmentUpload(connectionToken: Swift.String, attachmentIds: [Swift.String], completion: @escaping (Swift.Result<AWSConnectParticipant.AWSConnectParticipantCompleteAttachmentUploadResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func getAttachment(connectionToken: Swift.String, attachmentId: Swift.String, completion: @escaping (Swift.Result<AWSConnectParticipant.AWSConnectParticipantGetAttachmentResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func getTranscript(getTranscriptArgs: AWSConnectParticipant.AWSConnectParticipantGetTranscriptRequest, completion: @escaping (Swift.Result<AWSConnectParticipant.AWSConnectParticipantGetTranscriptResponse, any Swift.Error>) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func describeView(connectionToken: Swift.String, viewToken: Swift.String, completion: @escaping (Swift.Result<AWSConnectParticipant.AWSConnectParticipantDescribeViewResponse, any Swift.Error>) -> Swift.Void)
  #endif
  @objc deinit
}
public protocol MessageContent {
  #if compiler(>=5.3) && $NonescapableTypes
  static func decode(from text: Swift.String) -> (any AmazonConnectChatIOS.MessageContent)?
  #endif
}
public struct PlainTextContent : AmazonConnectChatIOS.MessageContent {
  public let text: Swift.String
  public init(text: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decode(from text: Swift.String) -> (any AmazonConnectChatIOS.MessageContent)?
  #endif
}
public struct GenericInteractiveTemplate : Swift.Decodable {
  public let templateType: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public protocol InteractiveContent : AmazonConnectChatIOS.MessageContent {
  static var templateType: Swift.String { get }
}
public struct QuickReplyElement : Swift.Codable {
  public let title: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct QuickReplyContentData : Swift.Codable {
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let elements: [AmazonConnectChatIOS.QuickReplyElement]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct QuickReplyData : Swift.Codable {
  public let content: AmazonConnectChatIOS.QuickReplyContentData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct QuickReplyTemplate : Swift.Codable {
  public let templateType: Swift.String
  public let version: Swift.String
  public let data: AmazonConnectChatIOS.QuickReplyData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct QuickReplyContent : AmazonConnectChatIOS.InteractiveContent {
  public static let templateType: Swift.String
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let options: [Swift.String]
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decode(from text: Swift.String) -> (any AmazonConnectChatIOS.MessageContent)?
  #endif
}
public struct ListPickerElement : Swift.Codable, Swift.Hashable, Swift.Equatable {
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let imageType: Swift.String?
  public let imageData: Swift.String?
  public static func == (a: AmazonConnectChatIOS.ListPickerElement, b: AmazonConnectChatIOS.ListPickerElement) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct ListPickerContentData : Swift.Codable {
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let imageType: Swift.String?
  public let imageData: Swift.String?
  public let elements: [AmazonConnectChatIOS.ListPickerElement]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ListPickerData : Swift.Codable {
  public let content: AmazonConnectChatIOS.ListPickerContentData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ListPickerTemplate : Swift.Codable {
  public let templateType: Swift.String
  public let version: Swift.String
  public let data: AmazonConnectChatIOS.ListPickerData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ListPickerContent : AmazonConnectChatIOS.InteractiveContent {
  public static let templateType: Swift.String
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let imageUrl: Swift.String?
  public let options: [AmazonConnectChatIOS.ListPickerElement]
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decode(from text: Swift.String) -> (any AmazonConnectChatIOS.MessageContent)?
  #endif
}
public struct PanelElement : Swift.Codable {
  public let title: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PanelContentData : Swift.Codable {
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let imageType: Swift.String?
  public let imageData: Swift.String?
  public let imageDescription: Swift.String?
  public let elements: [AmazonConnectChatIOS.PanelElement]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PanelReplyMessage : Swift.Codable {
  public let title: Swift.String
  public let subtitle: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PanelData : Swift.Codable {
  public let replyMessage: AmazonConnectChatIOS.PanelReplyMessage?
  public let content: AmazonConnectChatIOS.PanelContentData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PanelTemplate : Swift.Codable {
  public let templateType: Swift.String
  public let version: Swift.String
  public let data: AmazonConnectChatIOS.PanelData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PanelContent : AmazonConnectChatIOS.InteractiveContent {
  public static let templateType: Swift.String
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let imageUrl: Swift.String?
  public let imageDescription: Swift.String?
  public let options: [AmazonConnectChatIOS.PanelElement]
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decode(from text: Swift.String) -> (any AmazonConnectChatIOS.MessageContent)?
  #endif
}
public struct TimeSlot : Swift.Codable {
  public let date: Swift.String
  public let duration: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Location : Swift.Codable {
  public let latitude: Swift.Double
  public let longitude: Swift.Double
  public let title: Swift.String
  public let radius: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TimePickerContentData : Swift.Codable {
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let timeZoneOffset: Swift.Int?
  public let location: AmazonConnectChatIOS.Location?
  public let timeslots: [AmazonConnectChatIOS.TimeSlot]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TimePickerReplyMessage : Swift.Codable {
  public let title: Swift.String?
  public let subtitle: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TimePickerData : Swift.Codable {
  public let replyMessage: AmazonConnectChatIOS.TimePickerReplyMessage?
  public let content: AmazonConnectChatIOS.TimePickerContentData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TimePickerTemplate : Swift.Codable {
  public let templateType: Swift.String
  public let version: Swift.String
  public let data: AmazonConnectChatIOS.TimePickerData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TimePickerContent : AmazonConnectChatIOS.InteractiveContent {
  public static let templateType: Swift.String
  public let title: Swift.String
  public let subtitle: Swift.String?
  public let timeZoneOffset: Swift.Int?
  public let location: AmazonConnectChatIOS.Location?
  public let timeslots: [AmazonConnectChatIOS.TimeSlot]
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decode(from text: Swift.String) -> (any AmazonConnectChatIOS.MessageContent)?
  #endif
}
public struct CarouselElement : Swift.Codable {
  public let templateIdentifier: Swift.String
  public let templateType: Swift.String
  public let version: Swift.String
  public let data: AmazonConnectChatIOS.PanelData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CarouselContentData : Swift.Codable {
  public let title: Swift.String
  public let elements: [AmazonConnectChatIOS.CarouselElement]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CarouselData : Swift.Codable {
  public let content: AmazonConnectChatIOS.CarouselContentData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CarouselTemplate : Swift.Codable {
  public let templateType: Swift.String
  public let version: Swift.String
  public let data: AmazonConnectChatIOS.CarouselData
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CarouselContent : AmazonConnectChatIOS.InteractiveContent {
  public static let templateType: Swift.String
  public let title: Swift.String
  public let elements: [AmazonConnectChatIOS.CarouselElement]
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decode(from text: Swift.String) -> (any AmazonConnectChatIOS.MessageContent)?
  #endif
}
public struct ViewResourceContent : AmazonConnectChatIOS.InteractiveContent {
  public static let templateType: Swift.String
  public let viewId: Swift.String?
  public let content: [Swift.String : Any]?
  #if compiler(>=5.3) && $NonescapableTypes
  public static func decode(from text: Swift.String) -> (any AmazonConnectChatIOS.MessageContent)?
  #endif
}
public protocol ConnectionDetailsProviderProtocol {
  func updateChatDetails(newDetails: AmazonConnectChatIOS.ChatDetails)
  #if compiler(>=5.3) && $NonescapableTypes
  func getConnectionDetails() -> AmazonConnectChatIOS.ConnectionDetails?
  #endif
  func updateConnectionDetails(newDetails: AmazonConnectChatIOS.ConnectionDetails)
  #if compiler(>=5.3) && $NonescapableTypes
  func getChatDetails() -> AmazonConnectChatIOS.ChatDetails?
  #endif
  func isChatSessionActive() -> Swift.Bool
  func setChatSessionState(isActive: Swift.Bool)
  func reset()
}
public protocol EventProtocol : AmazonConnectChatIOS.TranscriptItemProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  var participant: Swift.String? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var text: Swift.String? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var displayName: Swift.String? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var eventDirection: AmazonConnectChatIOS.MessageDirection? { get set }
  #endif
}
public class Event : AmazonConnectChatIOS.TranscriptItem, AmazonConnectChatIOS.EventProtocol {
  public var participant: Swift.String?
  public var text: Swift.String?
  public var displayName: Swift.String?
  public var eventDirection: AmazonConnectChatIOS.MessageDirection?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(text: Swift.String? = nil, timeStamp: Swift.String, contentType: Swift.String, messageId: Swift.String, displayName: Swift.String? = nil, participant: Swift.String? = nil, eventDirection: AmazonConnectChatIOS.MessageDirection? = .Common, serializedContent: [Swift.String : Any])
  #endif
  @objc deinit
}
public protocol TranscriptItemProtocol : Combine.ObservableObject, Swift.Hashable, Swift.Identifiable {
  var id: Swift.String { get }
  var persistentId: Swift.String { get }
  var timeStamp: Swift.String { get }
  var contentType: Swift.String { get set }
  #if compiler(>=5.3) && $NonescapableTypes
  var serializedContent: [Swift.String : Any]? { get set }
  #endif
}
public class TranscriptItem : AmazonConnectChatIOS.TranscriptItemProtocol {
  public var id: Swift.String {
    get
  }
  public var persistentId: Swift.String {
    get
  }
  public var timeStamp: Swift.String {
    get
  }
  public var contentType: Swift.String
  public var serializedContent: [Swift.String : Any]?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(timeStamp: Swift.String, contentType: Swift.String, id: Swift.String?, serializedContent: [Swift.String : Any]?)
  #endif
  public static func == (lhs: AmazonConnectChatIOS.TranscriptItem, rhs: AmazonConnectChatIOS.TranscriptItem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias ID = Swift.String
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public struct TranscriptData {
  public let transcriptList: [AmazonConnectChatIOS.TranscriptItem]
  public let previousTranscriptNextToken: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(transcriptList: [AmazonConnectChatIOS.TranscriptItem], previousTranscriptNextToken: Swift.String?)
  #endif
}
public enum AttachmentTypes : Swift.String {
  case csv
  case doc
  case docx
  case heic
  case jpg
  case mov
  case mp4
  case pdf
  case png
  case ppt
  case pptx
  case rtf
  case txt
  case wav
  case xls
  case xlsx
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MessageStatus {
  case Delivered
  case Read
  case Sending
  case Failed
  case Sent
  case Unknown
  public static func == (a: AmazonConnectChatIOS.MessageStatus, b: AmazonConnectChatIOS.MessageStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol MetadataProtocol : AmazonConnectChatIOS.TranscriptItemProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  var status: AmazonConnectChatIOS.MessageStatus? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var eventDirection: AmazonConnectChatIOS.MessageDirection? { get set }
  #endif
}
public class Metadata : AmazonConnectChatIOS.TranscriptItem, AmazonConnectChatIOS.MetadataProtocol {
  #if compiler(>=5.3) && $NonescapableTypes
  @Combine.Published @_projectedValueProperty($status) public var status: AmazonConnectChatIOS.MessageStatus? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var $status: Combine.Published<AmazonConnectChatIOS.MessageStatus?>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @Combine.Published @_projectedValueProperty($eventDirection) public var eventDirection: AmazonConnectChatIOS.MessageDirection? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var $eventDirection: Combine.Published<AmazonConnectChatIOS.MessageDirection?>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(status: AmazonConnectChatIOS.MessageStatus? = nil, messageId: Swift.String? = nil, timeStamp: Swift.String, contentType: Swift.String, eventDirection: AmazonConnectChatIOS.MessageDirection? = .Common, serializedContent: [Swift.String : Any])
  #endif
  @objc deinit
}
public protocol SDKLoggerProtocol {
  func logVerbose(_ message: @autoclosure () -> Swift.String)
  func logInfo(_ message: @autoclosure () -> Swift.String)
  func logDebug(_ message: @autoclosure () -> Swift.String)
  func logFault(_ message: @autoclosure () -> Swift.String)
  func logError(_ message: @autoclosure () -> Swift.String)
}
public enum MessageDirection {
  case Outgoing
  case Incoming
  case Common
  public static func == (a: AmazonConnectChatIOS.MessageDirection, b: AmazonConnectChatIOS.MessageDirection) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol MessageProtocol : AmazonConnectChatIOS.TranscriptItemProtocol {
  var participant: Swift.String { get set }
  var text: Swift.String { get set }
  var contentType: Swift.String { get set }
  #if compiler(>=5.3) && $NonescapableTypes
  var displayName: Swift.String? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var messageDirection: AmazonConnectChatIOS.MessageDirection? { get set }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var metadata: (any AmazonConnectChatIOS.MetadataProtocol)? { get set }
  #endif
}
public class Message : AmazonConnectChatIOS.TranscriptItem, AmazonConnectChatIOS.MessageProtocol {
  public var participant: Swift.String
  public var text: Swift.String
  public var messageDirection: AmazonConnectChatIOS.MessageDirection?
  public var attachmentId: Swift.String?
  public var displayName: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  @Combine.Published @_projectedValueProperty($metadata) public var metadata: (any AmazonConnectChatIOS.MetadataProtocol)? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    set
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    _modify
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var $metadata: Combine.Published<(any AmazonConnectChatIOS.MetadataProtocol)?>.Publisher {
    get
    @available(iOS 14.0, tvOS 14.0, watchOS 7.0, macOS 11.0, *)
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(participant: Swift.String, text: Swift.String, contentType: Swift.String, messageDirection: AmazonConnectChatIOS.MessageDirection? = nil, timeStamp: Swift.String, attachmentId: Swift.String? = nil, messageId: Swift.String? = nil, displayName: Swift.String? = nil, serializedContent: [Swift.String : Any], metadata: (any AmazonConnectChatIOS.MetadataProtocol)? = nil, persistentId: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var content: (any AmazonConnectChatIOS.MessageContent)? {
    get
  }
  #endif
  @objc deinit
}
public struct GlobalConfig {
  public var region: AWSCore.AWSRegionType
  public var features: AmazonConnectChatIOS.Features
  public var disableCsm: Swift.Bool
  public var customAWSClient: AmazonConnectChatIOS.AWSClient?
  public var customWebSocketURLProvider: ((Swift.String) -> Swift.String)?
  public static var defaultRegion: AWSCore.AWSRegionType {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public init(region: AWSCore.AWSRegionType = defaultRegion, features: AmazonConnectChatIOS.Features = .defaultFeatures, disableCsm: Swift.Bool = false, customAWSClient: AmazonConnectChatIOS.AWSClient? = nil, customWebSocketURLProvider: ((Swift.String) -> Swift.String)? = nil)
  #endif
}
public struct Features {
  public var messageReceipts: AmazonConnectChatIOS.MessageReceipts
  public static var defaultFeatures: AmazonConnectChatIOS.Features {
    get
  }
  public init(messageReceipts: AmazonConnectChatIOS.MessageReceipts = .defaultReceipts)
}
public struct MessageReceipts {
  public var shouldSendMessageReceipts: Swift.Bool
  public var throttleTime: Swift.Double
  public static var defaultReceipts: AmazonConnectChatIOS.MessageReceipts {
    get
  }
  public init(shouldSendMessageReceipts: Swift.Bool, throttleTime: Swift.Double)
}
@_hasMissingDesignatedInitializers public class SDKLogger : AmazonConnectChatIOS.SDKLoggerProtocol {
  public static var isLoggingEnabled: Swift.Bool
  public func logVerbose(_ message: @autoclosure () -> Swift.String)
  public func logInfo(_ message: @autoclosure () -> Swift.String)
  public func logDebug(_ message: @autoclosure () -> Swift.String)
  public func logFault(_ message: @autoclosure () -> Swift.String)
  public func logError(_ message: @autoclosure () -> Swift.String)
  public static func configureLogger(_ logger: any AmazonConnectChatIOS.SDKLoggerProtocol)
  @objc deinit
}
public struct ChatDetails {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(contactId: Swift.String? = nil, participantId: Swift.String? = nil, participantToken: Swift.String)
  #endif
}
public struct ChatSessionOptions {
}
public enum ContentType : Swift.String {
  case typing
  case connectionAcknowledged
  case messageDelivered
  case messageRead
  case metaData
  case joined
  case left
  case ended
  case plainText
  case richText
  case json
  case interactiveText
  case interactiveResponse
  case authenticationInitiated
  case authenticationSuccessful
  case authenticationFailed
  case authenticationTimeout
  case authenticationExpired
  case authenticationCancelled
  case participantDisplayNameUpdated
  case participantActive
  case participantInactive
  case transferSucceeded
  case transferFailed
  case participantIdle
  case participantReturned
  case participantInvited
  case autoDisconnection
  case chatRehydrated
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MessageReceiptType : Swift.String {
  case messageDelivered
  case messageRead
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum WebSocketMessageType : Swift.String {
  case message
  case event
  case attachment
  case messageMetadata
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension AmazonConnectChatIOS.WebSocketErrorCodes : Swift.Equatable {}
extension AmazonConnectChatIOS.WebSocketErrorCodes : Swift.Hashable {}
extension AmazonConnectChatIOS.WebSocketErrorCodes : Swift.RawRepresentable {}
extension AmazonConnectChatIOS.AttachmentTypes : Swift.Equatable {}
extension AmazonConnectChatIOS.AttachmentTypes : Swift.Hashable {}
extension AmazonConnectChatIOS.AttachmentTypes : Swift.RawRepresentable {}
extension AmazonConnectChatIOS.MessageStatus : Swift.Equatable {}
extension AmazonConnectChatIOS.MessageStatus : Swift.Hashable {}
extension AmazonConnectChatIOS.MessageDirection : Swift.Equatable {}
extension AmazonConnectChatIOS.MessageDirection : Swift.Hashable {}
extension AmazonConnectChatIOS.ContentType : Swift.Equatable {}
extension AmazonConnectChatIOS.ContentType : Swift.Hashable {}
extension AmazonConnectChatIOS.ContentType : Swift.RawRepresentable {}
extension AmazonConnectChatIOS.MessageReceiptType : Swift.Equatable {}
extension AmazonConnectChatIOS.MessageReceiptType : Swift.Hashable {}
extension AmazonConnectChatIOS.MessageReceiptType : Swift.RawRepresentable {}
extension AmazonConnectChatIOS.WebSocketMessageType : Swift.Equatable {}
extension AmazonConnectChatIOS.WebSocketMessageType : Swift.Hashable {}
extension AmazonConnectChatIOS.WebSocketMessageType : Swift.RawRepresentable {}
